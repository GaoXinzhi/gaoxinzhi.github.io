---
title: "C++内存模型"
layout: single
author_profile: true
read_time: true
comments: true
share: true
related: true
show_date: true
toc: true
toc_label: "内存模型"
toc_icon: "file-alt"
tags: c++ 内存 # 调整文章的标签
categories: c++ # 调整文章的分类
excerpt: "c++程序执行过程中，会将内存大致分为四个区域，文章将对该四个区域进行介绍。"
# classes: wide # 如果没有右面的导航栏的话将内容进行右填充如果有右侧导航栏会很难看

# 开始的大图片以及上面的文字

header:
  teaser: ../postimage/c++mem/teaser.jpg #预览时显示的图片
#   overlay_image: ../assets/images/back.webp
#   # overlay_filter: rgba(255, 0, 0, 0.5)  #可以调整一些图像的色彩等
#   caption: "Photo credit: [**Unsplash**](https://unsplash.com)"
#   actions:
#     - label: "More Info"
#       url: "https://unsplash.com"

#这是作者栏那个位置的导航格如果想用这个东西先将上面的author_profile关掉

# sidebar: 
#   - title: "Title"
#     image: http://placehold.it/350x250
#     image_alt: "image"
#     text: "Some text here."
#   - title: "Another Title"
#     text: "More text here."
# 如果想一个更骚点的导航栏，像教程里的那样，参见 https://mmistakes.github.io/minimal-mistakes/docs/layouts/#custom-sidebar-navigation-menu
---

# C++内存模型

c++代码在执行过程中将内存大致分为4个区域分别为：

**代码区**：存放函数的二进制代码，由操作系统进行管理。

**全局区**：存放全局变量和静态变量以及常量。

**栈区**：由编译器自动分配和释放，存放函数的参数值局部变量等。

**堆区**：由程序员分配和释放，如果程序员不释放，则操作系统在程序结束使进行回收

其中，代码区和全局区在程序执行前就划分出来了，程序运行后才会划分出堆区和栈区。

## 代码区

在这个区里面会存储我们编写的所有程序，是CPU的**可执行指令**。

特点：

* **共享**：频繁执行的程序可以在内存中只存储一份

* **只读**：防止程序意外修改指令

## 全局区

**全局变量**和**静态变量**存放于此。全局区还包含了常量区，**字符串常量**和**其他常量**存放在此。该区域的数据在程序结束后由操作系统释放。

静态变量：在普通变量前面加static，属于静态变量。

常量：

* 字符串常量："hello world"像这种直接用双引号包起来的。

* const修饰的全局变量或者局部变量：但是全局常量存放在全局区，局部常量并不存放在全局区。

![global area](\postimage\c++mem\teaser.jpg){: .align-center}

## 栈区

由**编译器**自动分配释放，存放函数的参数值，局部变量等。

注意事项：不要返回局部变量的地址，栈区开辟的地址由编译器自动释放。

## 堆区

由**程序员**进行分配和释放，程序结束时操作系统会回收内存。在c++中主要是利用**new**关键字进行堆区内存分配，返回的是分配的堆区的地址。

```c++
int* func() {
  int *p = new int(10);
  return p;
}
```

在上面的例子中，虽然数据开辟到了堆区，但是p指针所在的位置仍然是栈区。


